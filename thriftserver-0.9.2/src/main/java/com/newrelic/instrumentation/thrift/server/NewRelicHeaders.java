/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.newrelic.instrumentation.thrift.server;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Generated;

import org.apache.thrift.EncodingUtils;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;
import org.apache.thrift.scheme.TupleScheme;

@SuppressWarnings({"rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (0.9.3)", date = "2023-04-10")
public class NewRelicHeaders {

	public interface Iface {

		public void newrelicHeaders(Map<String,String> headers) throws org.apache.thrift.TException;

		public boolean pingNewRelic() throws org.apache.thrift.TException;

	}

	public interface AsyncIface {

		public void newrelicHeaders(Map<String,String> headers, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

		public void pingNewRelic(org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException;

	}

	public static class newrelicHeaders_args implements org.apache.thrift.TBase<newrelicHeaders_args, newrelicHeaders_args._Fields>, java.io.Serializable, Cloneable, Comparable<newrelicHeaders_args>   {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("newrelicHeaders_args");

		private static final org.apache.thrift.protocol.TField HEADERS_FIELD_DESC = new org.apache.thrift.protocol.TField("headers", org.apache.thrift.protocol.TType.MAP, (short)1);

		private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
		static {
			schemes.put(StandardScheme.class, new newrelicHeaders_argsStandardSchemeFactory());
			schemes.put(TupleScheme.class, new newrelicHeaders_argsTupleSchemeFactory());
		}

		public Map<String,String> headers; // required

		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			HEADERS((short)1, "headers");

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
				case 1: // HEADERS
					return HEADERS;
				default:
					return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
		static {
			Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
			tmpMap.put(_Fields.HEADERS, new org.apache.thrift.meta_data.FieldMetaData("headers", org.apache.thrift.TFieldRequirementType.DEFAULT, 
					new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.MAP          , "Headers")));
			metaDataMap = Collections.unmodifiableMap(tmpMap);
			org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(newrelicHeaders_args.class, metaDataMap);
		}

		public newrelicHeaders_args() {
		}

		public newrelicHeaders_args(
				Map<String,String> headers)
		{
			this();
			this.headers = headers;
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public newrelicHeaders_args(newrelicHeaders_args other) {
			if (other.isSetHeaders()) {
				this.headers = other.headers;
			}
		}

		public newrelicHeaders_args deepCopy() {
			return new newrelicHeaders_args(this);
		}

		@Override
		public void clear() {
			this.headers = null;
		}

		public int getHeadersSize() {
			return (this.headers == null) ? 0 : this.headers.size();
		}

		public void putToHeaders(String key, String val) {
			if (this.headers == null) {
				this.headers = new HashMap<String,String>();
			}
			this.headers.put(key, val);
		}

		public Map<String,String> getHeaders() {
			return this.headers;
		}

		public newrelicHeaders_args setHeaders(Map<String,String> headers) {
			this.headers = headers;
			return this;
		}

		public void unsetHeaders() {
			this.headers = null;
		}

		/** Returns true if field headers is set (has been assigned a value) and false otherwise */
		public boolean isSetHeaders() {
			return this.headers != null;
		}

		public void setHeadersIsSet(boolean value) {
			if (!value) {
				this.headers = null;
			}
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case HEADERS:
				if (value == null) {
					unsetHeaders();
				} else {
					setHeaders((Map<String,String>)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case HEADERS:
				return getHeaders();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case HEADERS:
				return isSetHeaders();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof newrelicHeaders_args)
				return this.equals((newrelicHeaders_args)that);
			return false;
		}

		public boolean equals(newrelicHeaders_args that) {
			if (that == null)
				return false;

			boolean this_present_headers = true && this.isSetHeaders();
			boolean that_present_headers = true && that.isSetHeaders();
			if (this_present_headers || that_present_headers) {
				if (!(this_present_headers && that_present_headers))
					return false;
				if (!this.headers.equals(that.headers))
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_headers = true && (isSetHeaders());
			list.add(present_headers);
			if (present_headers)
				list.add(headers);

			return list.hashCode();
		}

		@Override
		public int compareTo(newrelicHeaders_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.valueOf(isSetHeaders()).compareTo(other.isSetHeaders());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetHeaders()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.headers, other.headers);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("newrelicHeaders_args(");
			sb.append("headers:");
			if (this.headers == null) {
				sb.append("null");
			} else {
				sb.append(this.headers);
			}
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class newrelicHeaders_argsStandardSchemeFactory implements SchemeFactory {
			public newrelicHeaders_argsStandardScheme getScheme() {
				return new newrelicHeaders_argsStandardScheme();
			}
		}

		private static class newrelicHeaders_argsStandardScheme extends StandardScheme<newrelicHeaders_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, newrelicHeaders_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true)
				{
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
						break;
					}
					switch (schemeField.id) {
					case 1: // HEADERS
						if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
							{
								org.apache.thrift.protocol.TMap _map0 = iprot.readMapBegin();
								struct.headers = new HashMap<String,String>(2*_map0.size);
								String _key1;
								String _val2;
								for (int _i3 = 0; _i3 < _map0.size; ++_i3)
								{
									_key1 = iprot.readString();
									_val2 = iprot.readString();
									struct.headers.put(_key1, _val2);
								}
								iprot.readMapEnd();
							}
							struct.setHeadersIsSet(true);
						} else { 
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
						}
						break;
					default:
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, newrelicHeaders_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.headers != null) {
					oprot.writeFieldBegin(HEADERS_FIELD_DESC);
					{
						oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, struct.headers.size()));
						for (Map.Entry<String, String> _iter4 : struct.headers.entrySet())
						{
							oprot.writeString(_iter4.getKey());
							oprot.writeString(_iter4.getValue());
						}
						oprot.writeMapEnd();
					}
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

		private static class newrelicHeaders_argsTupleSchemeFactory implements SchemeFactory {
			public newrelicHeaders_argsTupleScheme getScheme() {
				return new newrelicHeaders_argsTupleScheme();
			}
		}

		private static class newrelicHeaders_argsTupleScheme extends TupleScheme<newrelicHeaders_args> {

			@Override
			public void write(org.apache.thrift.protocol.TProtocol prot, newrelicHeaders_args struct) throws org.apache.thrift.TException {
				TTupleProtocol oprot = (TTupleProtocol) prot;
				BitSet optionals = new BitSet();
				if (struct.isSetHeaders()) {
					optionals.set(0);
				}
				oprot.writeBitSet(optionals, 1);
				if (struct.isSetHeaders()) {
					{
						oprot.writeI32(struct.headers.size());
						for (Map.Entry<String, String> _iter5 : struct.headers.entrySet())
						{
							oprot.writeString(_iter5.getKey());
							oprot.writeString(_iter5.getValue());
						}
					}
				}
			}

			@Override
			public void read(org.apache.thrift.protocol.TProtocol prot, newrelicHeaders_args struct) throws org.apache.thrift.TException {
				TTupleProtocol iprot = (TTupleProtocol) prot;
				BitSet incoming = iprot.readBitSet(1);
				if (incoming.get(0)) {
					{
						org.apache.thrift.protocol.TMap _map6 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.STRING, iprot.readI32());
						struct.headers = new HashMap<String,String>(2*_map6.size);
						String _key7;
						String _val8;
						for (int _i9 = 0; _i9 < _map6.size; ++_i9)
						{
							_key7 = iprot.readString();
							_val8 = iprot.readString();
							struct.headers.put(_key7, _val8);
						}
					}
					struct.setHeadersIsSet(true);
				}
			}
		}

	}

	public static class pingNewRelic_args implements org.apache.thrift.TBase<pingNewRelic_args, pingNewRelic_args._Fields>, java.io.Serializable, Cloneable, Comparable<pingNewRelic_args>   {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("pingNewRelic_args");


		private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
		static {
			schemes.put(StandardScheme.class, new pingNewRelic_argsStandardSchemeFactory());
			schemes.put(TupleScheme.class, new pingNewRelic_argsTupleSchemeFactory());
		}


		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			;

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
				default:
					return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}
		public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
		static {
			Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
			metaDataMap = Collections.unmodifiableMap(tmpMap);
			org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(pingNewRelic_args.class, metaDataMap);
		}

		public pingNewRelic_args() {
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public pingNewRelic_args(pingNewRelic_args other) {
		}

		public pingNewRelic_args deepCopy() {
			return new pingNewRelic_args(this);
		}

		@Override
		public void clear() {
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof pingNewRelic_args)
				return this.equals((pingNewRelic_args)that);
			return false;
		}

		public boolean equals(pingNewRelic_args that) {
			if (that == null)
				return false;

			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			return list.hashCode();
		}

		@Override
		public int compareTo(pingNewRelic_args other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			return lastComparison;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("pingNewRelic_args(");
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class pingNewRelic_argsStandardSchemeFactory implements SchemeFactory {
			public pingNewRelic_argsStandardScheme getScheme() {
				return new pingNewRelic_argsStandardScheme();
			}
		}

		private static class pingNewRelic_argsStandardScheme extends StandardScheme<pingNewRelic_args> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, pingNewRelic_args struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true)
				{
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
						break;
					}
					switch (schemeField.id) {
					default:
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, pingNewRelic_args struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

		private static class pingNewRelic_argsTupleSchemeFactory implements SchemeFactory {
			public pingNewRelic_argsTupleScheme getScheme() {
				return new pingNewRelic_argsTupleScheme();
			}
		}

		@SuppressWarnings("unused")
		private static class pingNewRelic_argsTupleScheme extends TupleScheme<pingNewRelic_args> {

			@Override
			public void write(org.apache.thrift.protocol.TProtocol prot, pingNewRelic_args struct) throws org.apache.thrift.TException {
				TTupleProtocol oprot = (TTupleProtocol) prot;
			}

			@Override
			public void read(org.apache.thrift.protocol.TProtocol prot, pingNewRelic_args struct) throws org.apache.thrift.TException {
				TTupleProtocol iprot = (TTupleProtocol) prot;
			}
		}

	}

	public static class pingNewRelic_result implements org.apache.thrift.TBase<pingNewRelic_result, pingNewRelic_result._Fields>, java.io.Serializable, Cloneable, Comparable<pingNewRelic_result>   {
		private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("pingNewRelic_result");

		private static final org.apache.thrift.protocol.TField SUCCESS_FIELD_DESC = new org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.BOOL, (short)0);

		private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
		static {
			schemes.put(StandardScheme.class, new pingNewRelic_resultStandardSchemeFactory());
			schemes.put(TupleScheme.class, new pingNewRelic_resultTupleSchemeFactory());
		}

		public boolean success; // required

		/** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
		public enum _Fields implements org.apache.thrift.TFieldIdEnum {
			SUCCESS((short)0, "success");

			private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

			static {
				for (_Fields field : EnumSet.allOf(_Fields.class)) {
					byName.put(field.getFieldName(), field);
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, or null if its not found.
			 */
			public static _Fields findByThriftId(int fieldId) {
				switch(fieldId) {
				case 0: // SUCCESS
					return SUCCESS;
				default:
					return null;
				}
			}

			/**
			 * Find the _Fields constant that matches fieldId, throwing an exception
			 * if it is not found.
			 */
			public static _Fields findByThriftIdOrThrow(int fieldId) {
				_Fields fields = findByThriftId(fieldId);
				if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
				return fields;
			}

			/**
			 * Find the _Fields constant that matches name, or null if its not found.
			 */
			public static _Fields findByName(String name) {
				return byName.get(name);
			}

			private final short _thriftId;
			private final String _fieldName;

			_Fields(short thriftId, String fieldName) {
				_thriftId = thriftId;
				_fieldName = fieldName;
			}

			public short getThriftFieldId() {
				return _thriftId;
			}

			public String getFieldName() {
				return _fieldName;
			}
		}

		// isset id assignments
		private static final int __SUCCESS_ISSET_ID = 0;
		private byte __isset_bitfield = 0;
		public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
		static {
			Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
			tmpMap.put(_Fields.SUCCESS, new org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
					new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
			metaDataMap = Collections.unmodifiableMap(tmpMap);
			org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(pingNewRelic_result.class, metaDataMap);
		}

		public pingNewRelic_result() {
		}

		public pingNewRelic_result(
				boolean success)
		{
			this();
			this.success = success;
			setSuccessIsSet(true);
		}

		/**
		 * Performs a deep copy on <i>other</i>.
		 */
		public pingNewRelic_result(pingNewRelic_result other) {
			__isset_bitfield = other.__isset_bitfield;
			this.success = other.success;
		}

		public pingNewRelic_result deepCopy() {
			return new pingNewRelic_result(this);
		}

		@Override
		public void clear() {
			setSuccessIsSet(false);
			this.success = false;
		}

		public boolean isSuccess() {
			return this.success;
		}

		public pingNewRelic_result setSuccess(boolean success) {
			this.success = success;
			setSuccessIsSet(true);
			return this;
		}

		public void unsetSuccess() {
			__isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		/** Returns true if field success is set (has been assigned a value) and false otherwise */
		public boolean isSetSuccess() {
			return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);
		}

		public void setSuccessIsSet(boolean value) {
			__isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);
		}

		public void setFieldValue(_Fields field, Object value) {
			switch (field) {
			case SUCCESS:
				if (value == null) {
					unsetSuccess();
				} else {
					setSuccess((Boolean)value);
				}
				break;

			}
		}

		public Object getFieldValue(_Fields field) {
			switch (field) {
			case SUCCESS:
				return isSuccess();

			}
			throw new IllegalStateException();
		}

		/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
		public boolean isSet(_Fields field) {
			if (field == null) {
				throw new IllegalArgumentException();
			}

			switch (field) {
			case SUCCESS:
				return isSetSuccess();
			}
			throw new IllegalStateException();
		}

		@Override
		public boolean equals(Object that) {
			if (that == null)
				return false;
			if (that instanceof pingNewRelic_result)
				return this.equals((pingNewRelic_result)that);
			return false;
		}

		public boolean equals(pingNewRelic_result that) {
			if (that == null)
				return false;

			boolean this_present_success = true;
			boolean that_present_success = true;
			if (this_present_success || that_present_success) {
				if (!(this_present_success && that_present_success))
					return false;
				if (this.success != that.success)
					return false;
			}

			return true;
		}

		@Override
		public int hashCode() {
			List<Object> list = new ArrayList<Object>();

			boolean present_success = true;
			list.add(present_success);
			if (present_success)
				list.add(success);

			return list.hashCode();
		}

		@Override
		public int compareTo(pingNewRelic_result other) {
			if (!getClass().equals(other.getClass())) {
				return getClass().getName().compareTo(other.getClass().getName());
			}

			int lastComparison = 0;

			lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(other.isSetSuccess());
			if (lastComparison != 0) {
				return lastComparison;
			}
			if (isSetSuccess()) {
				lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
				if (lastComparison != 0) {
					return lastComparison;
				}
			}
			return 0;
		}

		public _Fields fieldForId(int fieldId) {
			return _Fields.findByThriftId(fieldId);
		}

		public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
			schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
		}

		public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
			schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
		}

		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder("pingNewRelic_result(");
			sb.append("success:");
			sb.append(this.success);
			sb.append(")");
			return sb.toString();
		}

		public void validate() throws org.apache.thrift.TException {
			// check for required fields
			// check for sub-struct validity
		}

		private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
			try {
				write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
			try {
				// it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
				__isset_bitfield = 0;
				read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
			} catch (org.apache.thrift.TException te) {
				throw new java.io.IOException(te);
			}
		}

		private static class pingNewRelic_resultStandardSchemeFactory implements SchemeFactory {
			public pingNewRelic_resultStandardScheme getScheme() {
				return new pingNewRelic_resultStandardScheme();
			}
		}

		private static class pingNewRelic_resultStandardScheme extends StandardScheme<pingNewRelic_result> {

			public void read(org.apache.thrift.protocol.TProtocol iprot, pingNewRelic_result struct) throws org.apache.thrift.TException {
				org.apache.thrift.protocol.TField schemeField;
				iprot.readStructBegin();
				while (true)
				{
					schemeField = iprot.readFieldBegin();
					if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
						break;
					}
					switch (schemeField.id) {
					case 0: // SUCCESS
						if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
							struct.success = iprot.readBool();
							struct.setSuccessIsSet(true);
						} else { 
							org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
						}
						break;
					default:
						org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
					}
					iprot.readFieldEnd();
				}
				iprot.readStructEnd();

				// check for required fields of primitive type, which can't be checked in the validate method
				struct.validate();
			}

			public void write(org.apache.thrift.protocol.TProtocol oprot, pingNewRelic_result struct) throws org.apache.thrift.TException {
				struct.validate();

				oprot.writeStructBegin(STRUCT_DESC);
				if (struct.isSetSuccess()) {
					oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
					oprot.writeBool(struct.success);
					oprot.writeFieldEnd();
				}
				oprot.writeFieldStop();
				oprot.writeStructEnd();
			}

		}

		private static class pingNewRelic_resultTupleSchemeFactory implements SchemeFactory {
			public pingNewRelic_resultTupleScheme getScheme() {
				return new pingNewRelic_resultTupleScheme();
			}
		}

		private static class pingNewRelic_resultTupleScheme extends TupleScheme<pingNewRelic_result> {

			@Override
			public void write(org.apache.thrift.protocol.TProtocol prot, pingNewRelic_result struct) throws org.apache.thrift.TException {
				TTupleProtocol oprot = (TTupleProtocol) prot;
				BitSet optionals = new BitSet();
				if (struct.isSetSuccess()) {
					optionals.set(0);
				}
				oprot.writeBitSet(optionals, 1);
				if (struct.isSetSuccess()) {
					oprot.writeBool(struct.success);
				}
			}

			@Override
			public void read(org.apache.thrift.protocol.TProtocol prot, pingNewRelic_result struct) throws org.apache.thrift.TException {
				TTupleProtocol iprot = (TTupleProtocol) prot;
				BitSet incoming = iprot.readBitSet(1);
				if (incoming.get(0)) {
					struct.success = iprot.readBool();
					struct.setSuccessIsSet(true);
				}
			}
		}

	}

}
